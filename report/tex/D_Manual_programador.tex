\apendice{Documentación técnica de programación}

\section{Introducción}

El proyecto al estar descompuesto en microservicios tiene varias partes bien diferenciadas. Esto se refleja en todas las partes del proyecto. 

\section{Estructura de directorios}

\begin{tabbing}
\hphantom{tab }\= \hphantom{tab }\= \hphantom{tab }\= \hphantom{tab }\= \hphantom{quadruple tabula}\= \kill\\
WhatAClass/ \> \> \> \> \> \textit{Principal localización para nuestro código fuente}\\
\> blueprints/ \> \> \> \> \textit{Localización de los controladores}\\
\> \> oauth/ \> \> \> \textit{Controladores de OAuth}\\
\> static/ \> \> \> \> \textit{Archivos estáticos (bootstrap y favicon)}\\
\> templates/ \> \> \> \> \textit{Plantillas de Jinja2 para generar html o javascript}\\
\> \> tensorflow\_mng/ \> \> \> \textit{Plantillas para tensorflow}\\
\> \> user\_mng/\> \> \> \textit{Plantillas para el control de usuarios}\\
\> \> \> email/ \> \> \textit{Plantillas para los email}\\
\> translations/ \> \> \> \> \textit{Mensajes traducidos (compilación)} \\
\> utils/ \> \> \> \> \textit{Utilidades} \\
\> \> email.py \> \> \> \textit{Utilidad de email}\\
\> app.py \> \> \> \> \textit{Builder}\\
\> extensions.py \> \> \> \> \textit{Extesiones de flask}\\
\> forms.py \> \> \> \> \textit{Formularios}\\
\> models.py \> \> \> \> \textit{Modelos}\\
Alembic/ \> \> \> \> \> \textit{Versionado de la DB}\\
\> versions/ \> \> \> \> \textit{Scripts de migración entre versiones de la DB}\\
babel/ \> \> \> \> \> \textit{Mensajes con sus traducciones}\\
config/ \> \> \> \> \> \textit{Configuración de la aplicación}\\
\> default.py \> \> \> \> \textit{Configuración por defecto}\\
docs/ \> \> \> \> \> \textit{Documentación autogenerada}\\
report/ \> \> \> \> \> \textit{Documentación manual}\\
resources/\> \> \> \> \> \textit{Recursos como claves rsa}\\
tests/ \> \> \> \> \> \textit{Tests de la aplicación}\\
.coveragerc \> \> \> \> \> \textit{Que código se ignora por el cubrimiento}\\
.dockerignore \> \> \> \> \> \textit{Que ignora docker}\\
.gitignore \> \> \> \> \> \textit{Que ignora git}\\
.travis.yml \> \> \> \> \> \textit{Configuración de travis}\\
babel.cfg \> \> \> \> \> \textit{Configuración de babel (internacionalización)}\\
create\_db.py \> \> \> \> \> \textit{Script de creación de la DB a partir del modelo}\\
docker-compose.yml \> \> \> \> \> \textit{Configuración de docker compose (solo webapp)}\\
Dockerfile \> \> \> \> \> \textit{Descripción de construcción del contenedor}\\
LICENSE \> \> \> \> \> \textit{Licencia}\\
messages.pot \> \> \> \> \> \textit{Mensajes traducidos}\\
Procfile \> \> \> \> \> \textit{Comandos para heroku}\\
README.md \> \> \> \> \> \textit{Readme para Github}\\
requirements.txt \> \> \> \> \> \textit{Requisitos para desarrollador y para VersionEye}\\
requirements-prod.txt \> \> \> \> \> \textit{Requisitos para despliegue}\\
run.py \> \> \> \> \> \textit{Punto de entrada para debug} \\
runtime.txt \> \> \> \> \> \textit{Establece la versión de python para heroku}\\
setup.cfg \> \> \> \> \> \textit{Alias para test}\\
setup.py \> \> \> \> \> \textit{Instalación de las dependencias}\\
start.py \> \> \> \> \> \textit{Punto de entrada sin configuración adicional}\\
test.py \> \> \> \> \> \textit{Punto de entrada para los test}\\
uwsgi.ini  \> \> \> \> \> \textit{Configuración para que uwsgi encuentra la aplicación}\\
wsgi.py  \> \> \> \> \> \textit{Punto de entrada para uwsgi}\\
\end{tabbing}

%_______________________________________________
\section{Manual del programador}

Se recomienda usar un IDE aunque no es necesario. Con el \emph{script} `run.py' podemos ejecutar la aplicación para \emph{debug}. 

Para añadir cosas a la página web necesitaremos de conocimientos de Flask o de un \emph{framework} web similar, Spring (Java) es similar a como funciona Flask, aunque como cabe esperar tiene diferencias considerables.

Tras conocer Flask debemos conocer sus \emph{blueprints}. Estas son una herramienta que principalmente nos deja descomponer el código en varios apartados permitiendo mantener distintas partes de la aplicación por distintas personas.

Para añadir la \emph{blueprint} a la aplicación nos debemos dirigir a WhatAClass/app.py ya que es el archivo donde esta la factoría de la aplicación. Ya hay ejemplos codificados de esto en `app.py' y solo tenemos que verlos y los lugares de donde hemos importado esas \emph{blueprints} para saber cómo seguir desarrollando sistemas similares.


 

\section{Compilación, instalación y ejecución del proyecto}

Se recomienda usar un gestor de entornos virtuales como venv, pyenv, conda\ldots

Para este ejemplo usaremos el recomendado por la documentación oficial de python venv: 
	
Para crearlo: `python3 -m venv ./venv'
	
Para activarlo: `source venv/bin/activate'

Para desactivarlo: `deactivate'

Los pasos para instalar el servicio web son:
\begin{list}{-}{}
\item sudo apt install git python3-pip
\item git clone https://github.com/Jazriel/WhatAClass.git
\item cd WhatAClass
\item sudo pip3 install -r requirements.txt
\end{list}

La instalación se puede hacer desde los fuentes con `sudo pip3 install -r requirements.txt' o con `sudo pip3 install --editable .'. Esto usa o requirements.txt o setup.py para instalar las dependencias, ahora mismo se favorece la instalación con el primer comando. Al ser Python un lenguaje interpretado no necesitamos compilarlo manualmente, se compilará JIT (just in time).

Para ejecutar en desarrollo lo mejor sería usar el \emph{script} `run.py' (\emph{script} específico para desarrollo, no se puede usar en producción), aunque se puede usar un \emph{script} listo para producción no se recomienda ya que los errores son menos descriptivos y mucho más difíciles de solventar.

\section{Despliegue}

Para desplegar esta preparado para ser desplegado con docker cuya instalación se puede encontrar en el siguiente enlace:  \href{https://docs.docker.com/engine/installation}{instalación de docker} 
	

Se puede ejecutar con docker pero se recomienda usar docker-compose:

user@machine:~/folder\$ docker-compose build \& \& docker-compose up 

Esto nos permite saltarnos toda la instalación de programador, ya que todo eso se hace automáticamente.

Hay gente que avoca por tener el entorno de programación dentro de un contenedor. Según las necesidades de la persona y del proyecto en particular esto puede ser una buena idea. 


\section{Pruebas del sistema}

Las pruebas se pueden ejecutar con test.py que lanza los tests de la carpeta tests/. si queremos ver el recubrimiento de el codigo podemos usar una herramienta como coverage y ejecutar test.py a traves de esa herramienta.  


\section{Microservicios}

Todo esto es sólo la estructura de la parte web y de control de sesión de la aplicación, ya que se dispone de la parte de minería la cual tiene su propia estructura de archivos...

Al ser tan simple como es, no se ha considerado necesario explicar todo lo que contiene. Los .py son \eng{scripts} para ejecutar las funciones necesarias, la carpeta test tiene los test y el Dockerfile, como en el punto anterior, tiene los pasos para la construcción del contenedor.
