El objetivo principal del proyecto es el crear una aplicación web, esta debe tener control de usuarios y capacidad de clasificar imágenes mediante una red neuronal. Por último, debe ser capaz de re-entrenar el modelo de clasificación de imágenes.

Además se pide que todo esto se haga de una manera escalable, desplegable y con un enfoque que reduzca la deuda técnica.

La escalabilidad es un concepto claro pero muy abstracto \cite{hill90}, Bondi \cite{bondi00} la define como la capacidad de un sistema para ser capaz de ampliarse para manejar mayor cantidad de trabajo. 

Desde el punto de vista de mantenimiento, un sistema escalable es aquel que podemos modificar para corregir, ampliar o cambiar atributos con facilidad. En el mundo software es una propiedad compleja ya que existen varias fuentes de ampliación del sistema. La primera de ellas, aumentando el número de copias del software que se ejecutan, de forma local o distribuida. Otra forma es descomponer el sistema en subsistemas, estos más reducidos son más fácil de mantener y de escalar a la medida necesaria. La última es separar los servicios en particiones distintas, de manera que cada partición se encarga de dar servicio a una subconjunto de los usuarios.

Estas tres opciones de escalado se denominan en el libro \emph{The Art of Scaling} \cite{scala09} como el `\emph{cubo de la escalabilidad}'. 

Se busca obtener un sistema escalable en los dos primeros ejes de escalado. Al usar virtualización por medio de contenedores podremos ejecutar el numero de copias del software que queramos. La segunda dimensión la obtendremos con la arquitectura de microservicios. 

Todo este conocimiento se usa para crear un sistema que facilite la clasificación de imágenes, debido al reciente interes por el aprendizaje automático y el enfoque `AI first'. Esto se hace usando \eng{Tensorflow} \cite{tf}. La red neuronal a usar es Inception v3 \cite{incep} y el conjunto de datos es Imagenet \cite{imnet}.

La escalabilidad que se plantea que alcance este sistema es tanto de rendimiento como de mantenimiento. Se busca proporcionar una arquitectura fácilmente escalable en ambos sentidos, cuyo reflejo en código no sea complejo  para facilitar el futuro mantenimiento. 