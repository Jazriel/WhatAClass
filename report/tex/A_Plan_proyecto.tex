\apendice{Plan de Proyecto Software}

\section{Introducción}

La planificación es un punto importante en cualquier proyecto. Estimar el trabajo, el tiempo y el dinero que va a suponer la realización del proyecto, aunque vaya a cambiar más tarde, es interesante para saber si puede haber posibilidades de que sea viable. Para ello, debemos analizar cuidadosamente los componentes del proyecto. Con este análisis pretendemos conocer los requisitos del proyecto y pretendemos que mediante modificaciones siga sirviendo en un futuro.

\section{Planificación temporal}
En un principio se planteó seguir una metodología ágil, esta sería \eng{Scrum} \cite{scrum} ya que existía experiencia anterior. Por supuesto, no se pudo usar completamente ya que no se tenía un equipo, no se hicieron reuniones diarias\ldots

Se empezó a usar ZenHub como tablero kanban donde se situarían las tareas con sus costes. Este tipo de planificación con \emph{milestones} e \emph{issues} no ha sido seguido la mayor parte del tiempo, ya que no era la metodología más adecuada. Las labores de investigación que no tenían ningún entregable claro no se incluyeron en el repositorio a partir de cierto punto para no acumular demasiada información innecesaria.

En retrospectiva, se ha concluido que una forma mejor de hacer este tipo de trabajos es llevar varios tableros kanban en varios repositorios: uno para todo el proyecto y otro para todo el informe del proyecto en vez de todo junto.

\subsection{Sistema de \emph{sprints}}

El sistema de \emph{sprints} no fue un constante a lo largo del desarrollo del proyecto, esto se debió al hecho de que algunas cosas se hicieran antes de empezar el cuatrimestre por cuestiones de balanceamiento de la carga de trabajo.

Lo que esto supuso es que, antes de empezar con el sistema de \emph{sprints}, se usase el tiempo de 1-3 \emph{sprints} para aprender Flask, tras este periodo, se llevó un sistema más estandarizado de \emph{sprints}, estos se pueden ver en los \emph{milestones} de GitHub y en las \emph{issues}. Por problemas en cómo se movieron las \emph{issues} por el tablero (a \emph{QA} hasta la reunión del \emph{sprint}), no se pudieron sacar gráficos automatizados suficientemente exactos, ya que acaban siendo un peldaño enorme en la reunión del \emph{sprint}.

Tras una serie de semanas llevando este sistema, se tubo que abandonar por varios motivos. Los \emph{sprints} empezaron a ser menos concretos y más basados en la investigación y desarrollo de la alternativa más atrayente, la carga de trabajo del resto de asignaturas se tenía en picos, propiciando \emph{sprints} con mucho trabajo y otros sin casi nada y, por último, una serie de circunstancias personales hicieron que acabase por abandonar la documentación de cada \emph{sprint} \emph{online}.

\subsubsection{Sprints antes del cuatrimestre}
Antes del cuatrimestre como se ha comentado se siguieron una serie de \emph{sprints}, estos se basaron en seguir el tutorial \eng{explore Flask}. El \emph{sprint} se llevo a cabo con éxito, terminando aquello que se tenía pensado hacer, una aplicación Flask.

\subsubsection{Sprint 1}
En este \emph{sprint} se planteó el hecho de mover el trabajo anterior a una plataforma como Git y llevar el desarrollo más formalmente. También se empezó a investigar sobre subida de archivos y subida de archivos tipo \emph{drag and drop}. La subida de archivos se consiguió con un poco de retraso, pero el \emph{drag and drop} no. Esto se debe a mi inexperiencia en desarrollo \emph{front end}.


\subsubsection{Sprint 2}
En este \emph{sprint} se empezó a subir el código a Heroku, comprobando que se podía desplegar en condiciones reales. Se intentó mejorar la interfaz gráfica.

\subsubsection{Sprint 3}
Se empezó a generar documentación fuera de código. Este \emph{sprint} fue lento y no muy productivo, ya que no se sabía cómo se quería desarrollar la documentación. En este punto se desarrolló como una comparativa entre todas las alternativas hasta el momento, lo cual no ha sido la dirección que ha tomado el proyecto con el tiempo.

\subsubsection{Sprint 4-6}
En esta serie de \emph{sprints} se planteó la elección del \emph{framework} de \emph{Machine Learning}  que usar. Se investigaron tres alternativas \hfoot{http://scikit-learn.org/stable/}{sklearn}, \hfoot{http://www.deeplearning.net/software/theano/}{Theano} y \hfoot{https://www.tensorflow.org/}{Tensorflow}, aunque de tener la opción ahora se hubiese elegido \hfoot{https://keras.io/}{Keras}.

Keras parece una muy buena opción debido a que tiene una \eng{API} de alto nivel y muy intuitiva, si se quiere ver un ejemplo el siguiente \hfoot{https://github.com/fchollet/keras/blob/master/examples/mnist\_cnn.py}{script de Keras} quizá sea un buen ejemplo de lo sencillo que puede ser el usar Keras. 
Además proporciona estabilidad en la \eng{API} y permite usar Tensorflow, Theano o \hfoot{https://docs.microsoft.com/en-us/cognitive-toolkit/}{CNTK} (\eng{Microsoft Cognitive Toolkit}) \eng{backends}.

También se empezó a implementar la integración, algo que no se pudo cumplir y que acabó resultando mucho más costoso de lo que se había pensado previamente.



\subsubsection{Sprint 7}
En este \emph{sprint} se pretendía mejorar la aplicación y documentar mucho de los \emph{sprints} anteriores.
En este punto se empiezan a tener problemas con el seguimiento de las tareas de manera online.

\subsubsection{Docker}
Tras investigar sobre el tema, se decidió poner algo de énfasis en el despliegue, ya que ya se había intentado y llevado a cabo con \emph{Heroku}. De los contenedores existentes se tubo que investigar y decir si usarlos y cuál. La decisión fue \emph{Docker} , al ser la única alternativa que tenía proyectos en producción. En el momento de la elección era totalmente \emph{open source}, algo que cambió con el tiempo y tras lo cuál hubo que hacer otra investigación de cómo influía el cambio. Resultó no influir apenas, puede ser que una vez maduren otras alternativas haya que intentar deshacerse de \emph{Docker}.\cite{learndock}

\subsubsection{Transfer learning}
Tras investigar un poco sobre cómo se podía hacer la integración con Tensorflow, se vió que el \emph{transfer learning} de un modelo como inception v3 era suficientemente simple como para intentar llevarlo a cabo.
Se desarrollaron los \emph{scripts} para predecir clases a partir de imágenes.

\subsubsection{Docker Compose y Swarm}
\emph{Docker Compose} y \emph{Docker Swarm} fueron una de las razones por las que se eligió \emph{Docker} en vez de otras alternativas, pero aún así la barrera de entrada a estas tecnologías estaba lo suficientemente alta como para que \emph{Swarm} acabase siendo inalcanzable. \cite{orchdock}

\subsubsection{Microservicios}
Los microservicios se empezaron a conocer gracias a \emph{Docker}, ya que son una alternativa muy usada en este tipo de sistemas, al tener una relación simbiótica. Cada uno beneficia al otro.

\subsubsection{Escalabilidad y despliegue de páginas web}
Por último, se decidió centrar el proyecto en parte en la escalabilidad, ya que en dos de los ejes ya estaba, y para implementarlo en el tercero sólo hacía falta cambiar de una imagen de la base de datos a otra. Este último cambio no se llevo a cabo porque, salvo en aplicaciones excesivamente grandes, el usar una base de datos normal es más beneficioso.

\section{Estudio de viabilidad}
En este apartado se estudiaran los costes en los que se incurren al desarrollar este proyecto.

\subsection{Viabilidad económica}
El proyecto incurre en distintos tipos de costes

\subsubsection{Costes de personal}
El proyecto se lleva a cabo por un desarrollador junior empleado a tiempo parcial (30h/semana) durante cuatro meses. Se considera el siguiente salario:

\FloatBarrier
\begin{table}[]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Concepto & Coste (\euro{}) \\ \midrule
Salario neto & 1000 \\
Retención IRPF (19 \%) & 360.53 \\
Seguridad social (28,30 \%) & 537.00 \\
Salario bruto & 1897.53 \\ \midrule
4 meses tiempo parcial(3/4) & 5692.59 \\ \bottomrule
\end{tabular}
\caption{Costes de personal}
\label{Salario}
\end{table}

\subsubsection{Costes de material: hardware y software}

Como material podemos considerar lo mínimo necesario para llevar un proyecto así:

Un único coste puntual (ordenador portátil) que aproximamos en 600\euro{} y en la tabla se pondrá su coste amortizado contando con una amortización a 4 años. Se ha comprobado que internet está incluido en el alquiler de la oficina.
\FloatBarrier
\begin{table}[]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Concepto & Coste (\euro{}) \\ \midrule
Ordenador portátil & 25 \\
Alquiler de oficina & 99 \\
1 mes & 124 \\ \midrule
4 meses  & 496 \\ \bottomrule
\end{tabular}
\caption{Costes de material al mes}
\label{Costes mensualmente}
\end{table}


\subsubsection{Costes totales}
El sumatorio de todos los costes es de 6188,59\euro{}. Podríamos recortar más en ciertos puntos, pero debido a que no se va a llevar a cabo como está planteado aquí, esto solo es una aproximación del coste de oportunidad.




\subsection{Beneficios}
Si nuestro interés fuese vender el proyecto, este no sería el proyecto que venderíamos, tendríamos que añadir medidas de tiempo computacional en cada operación, de manera que cada clasificación o re-entrenamiento cobrásemos cierta cantidad de dinero en relación al tiempo computacional usado. Esto se traduce a una explotación del tipo SaaS (Software as a Service).

De esta manera podemos crear planes para cada usuario, podemos plantearnos hacer un plan gratuito y varios planes de pago según cantidad de tiempo computacional que se le permita usar al cliente.


\subsection{Viabilidad legal}

La licencia necesaria para nuestro proyecto, debido a las dependencias que tiene, tendrá que ser compatible con aquellas de las bibliotecas que hemos usado. La licencia más restrictiva que hemos usado es la de paramiko siendo LGPL (2.1 y 3.0)\cite{LGPL}, esta licencia está pensada para librerías e incluye el siguiente párrafo:

\begin{quotation}5. A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a "work that uses the Library". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License.
\end{quotation}

Por lo que las restricciones de esa licencia no se nos aplican. Esto quiere decir que podemos publicar nuestro código bajo la licencia que mejor nos parezca o incluso podríamos mantenerlo privado como un Secreto de negocio (\eng{trade secret}) ya que proporcionamos SaaS. Basándome en las licencias \eng{open source} más comunes, ya que me parece interesante el hecho de que otras personas puedan usar el código, y con ayuda de las recomendaciones de GNU \cite{gnurecs}, se ha decidido usar la GNU GPL 3.0.

Para la documentación se ha decidido que la mejor licencia para las necesidades era la GNU FDL (GNU Free Documentation License). La segunda alternativa más interesante era Creative Commons.

Para completar la documentación sobre la viabilidad legal se adjunta una tabla con todas las dependencias del proyecto.
\FloatBarrier
\begin{table}[]
\centering
\begin{tabular}{lll}
\hline
Dependencia & Versión & Licencia \\ \hline
Alembic & 0.9.5 & MIT \\
Bcrypt & 3.1.3 & Apache 2.0 \\
Flask & 0.12.2 & BSD \\
Flask-Babel & 0.11.2 & BSD \\
Flask-Bcrypt & 0.7.1 & BSD \\
Flask-Login & 0.4.0 & MIT \\
Flask-SQLAlchemy & 2.2 & BSD \\
Flask-Oauthlib & 0.9.4 & BSD \\
Flask-WTF & 0.14.2 & BSD \\
itsdangerous & 0.24 & BSD \\
Jinja2 & 2.9.6 & BSD \\
Paramiko & 2.2.1 & LGPL-3.0 \\
Psycopg2 & 2.7.3 & LGPL-3.0 \\
SQLAlchemy &1.1.13 & MIT \\
Werkzeug & 0.12.2 & BSD \\
WTForms & 2.1 & BSD \\ \hline
\end{tabular}
\caption{Dependencias del proyecto en produccin}
\label{Dependencias en produccin}
\end{table}


\begin{table}[]
\centering
\begin{tabular}{lll}
\hline
Dependencia & Versión & Licencia \\ \hline
codeclimate-test-reporter & 0.2.3 & MIT \\
coverage & 4.4.1 & Apache 2.0 \\ 
Pytest & 3.2.1 & MIT \\ \hline
\end{tabular}
\caption{Dependencias exclusivas del desarrollo}
\label{Dependencias exclusivas en desarrollo}
\end{table}


