\apendice{Plan de Proyecto Software}

\section{Introducción}

La planificación es un punto importante en cualquier proyecto. Estimar el trabajo, el tiempo y el dinero que va a suponer la realización del proyecto aunque vaya a cambiar más tarde es interesante para saber si puede haber posibilidades de que sea viable. Para ello, debemos analizar cuidadosamente los componentes del proyecto. Con este análisis pretendemos conocer los requisitos del proyecto y pretendemos que mediante modificaciones siga sirviendo en un futuro.

\section{Planificación temporal}
En un principio se planteo seguir una metodología ágil, esta sería scrum ya que existía experiencia anterior. Por supuesto no se pudo usar completamente ya que no se tenía un equipo, no se hicieron reuniones diarias\ldots

Se empezó a usar ZenHub como tablero kanban donde se situarían las tareas con sus costes. Este tipo de planificación con \emph{milestones} e \emph{issues} no ha sido seguido la mayor parte del tiempo ya que no era la metodología más adecuada. En labores de investigación que no se sabían si iban a ser usables más adelante las cuales no tenían ningún entregable claro se decidió no incluirlas a partir de cierto punto para no acumular demasiada información innecesaria en el repositorio.

En retrospectiva se ha deducido que una forma mejor de hacer este tipo de trabajos es llevar varios tableros kanban en varios repositorios: uno para todo el proyecto y otro para todo el informe del proyecto en vez de todo junto.

\subsection{Sistema de \emph{sprints}}

El sistema de \emph{sprints} no fue un constante a lo largo del desarrollo del proyecto, esto se debió a el hecho de que algunas cosas se hicieran antes de empezar el cuatrimestre por cuestiones de balanceamiento de la carga de trabajo.

Lo que esto supuso es que antes de empezar con el sistema de \emph{sprints} se usase el tiempo de 1-3 \emph{sprints} para aprender Flask, tras este periodo se llevó un sistema más estandarizado de \emph{sprints}, estos se pueden ver en las \emph{milestones} de GitHub y en las \emph{issues}. Por problemas en cómo se movieron las \emph{issues} por el tablero (a \emph{QA} hasta la reunión del \emph{sprint}), no se pudieron sacar gráficos automatizados suficientemente exactos, ya que acaban siendo un peldaño enorme en la reunión del \emph{sprint}.

Tras una serie de semanas llevando este sistema, se tubo que abandonar por varios motivos. Los \emph{sprints} empezaron a ser menos concretos y más basados en la investigación y desarrollo de la alternativa más atrayente, la carga de trabajo del resto de asignaturas se tenía en picos, propiciando \emph{sprints} con mucho trabajo y otros sin casi nada y por último una serie de circunstancias personales hicieron que acabase por abandonar la documentación de cada \emph{sprint} \emph{online}.

\subsubsection{Sprints antes del cuatrimestre}
Antes del cuatrimestre como se ha comentado se siguieron una serie de \emph{sprints}, estos se basaron en seguir el tutorial explore Flask. El \emph{sprint} se llevo a cabo con éxito, terminando aquello que se tenía pensado hacer, una aplicación Flask.

\subsubsection{Sprint 1}
En este \emph{sprint} se planteo el hecho de mover el trabajo anterior a una plataforma como Git y llevar el desarrollo más formalmente. También se empezó a investigar sobre subida de archivos y subida de archivos tipo \emph{drag and drop}. La subida de archivos se consiguió con un poco de retraso pero el \emph{drag and drop} no. Esto se debe a mi inexperiencia en desarrollo \emph{front end}.


\subsubsection{Sprint 2}
En este \emph{sprint} se empezó a subir el código a Heroku, comprobando que se podía desplegar en condiciones reales. Se intentó mejorar la interfaz gráfica.

\subsubsection{Sprint 3}
Se empezó a generar documentación fuera de código. Este \emph{sprint} fue lento y no muy productivo ya que no se sabía cómo se quería desarrollar la documentación. En este punto se desarrolló como una comparativa entre todas las alternativas hasta el momento, lo cual no ha sido la dirección que ha tomado el proyecto con el tiempo.

\subsubsection{Sprint 4-6}
En esta serie de \emph{sprints} se planteo la elección del \emph{framework} de \emph{Machine Learning}  que usar. La decisión se investigó más entre sklearn, Theano y Tensorflow, aunque de tener la opción ahora se hubiese elegido Keras.

También se empezó a implementar la integración, algo que no se pudo cumplir y que acabó resultando mucho más costoso de lo que se había pensado previamente.

\subsubsection{Sprint 7}
En este \emph{sprint} se pretendía mejorar la aplicación y documentar mucho de los \emph{sprints} anteriores.
En este punto se empiezan a tener problemas con el seguimiento de las tareas de manera online.

\subsubsection{Docker}
Tras investigar sobre el tema se decidió poner algo de énfasis en el despliegue ya que ya se había intentado y llevado a cabo con \emph{Heroku}. De los contenedores existentes se tubo que investigar y decir si usarlos y cual. La decisión fue \emph{Docker} al ser la única alternativa que tenía proyectos en producción. En el momento de la elección era totalmente \emph{open source}, algo que cambió con el tiempo y tras lo cuál hubo que hacer otra investigación de cómo influía el cambio. Resulto no influir apenas, puede ser que una vez maduren otras alternativas haya que intentar desacerse de \emph{Docker}

\subsubsection{Transfer learning}
Tras investigar un poco sobre cómo se podía hacer la integración con Tensorflow, se vió que el \emph{transfer learning} de un modelo como inception v3 era suficientemente simple como para intentar llevarlo a cabo.
Se desarrollaron los \emph{scripts} para predecir clases a partir de imágenes.

\subsubsection{Docker Compose y Swarm}
\emph{Docker Compose} y \emph{Docker Swarm} fueron una de las razones por las que se eligió \emph{Docker} en vez de otras alternativas, pero aún así la barrera de entrada a estas tecnologías estaba lo suficientemente alta como para que \emph{Swarm} acabase siendo inalcanzable.

\subsubsection{Microservicios}
Los microservicios se empezaron a conocer gracias a \emph{Docker}, ya que son una alternativa muy usada en este tipo de sistemas al tener una relación simbiótica. Cada uno beneficia al otro.

\subsubsection{Escalabilidad y despliegue de páginas web}
Por último se decidió centrar el proyecto en parte en la escalabilidad ya que en dos de los ejes ya estaba, y para implementarlo en el tercero sólo hacía falta cambiar de una imagen de la base de datos a otra. Este último cambio no se llevo a cabo porque, salvo en aplicaciones excesivamente grandes, el usar una base de datos normal es más beneficioso.

\section{Estudio de viabilidad}
En este apartado se estudiaran los costes en los que se incurren al desarrollar este proyecto.

\subsection{Viabilidad económica}
El proyecto incurre en distintos tipos de costes

\subsubsection{Costes de personal}
El proyecto se lleva a cabo por un desarrollador junior empleado a tiempo parcial (30h/semana) durante cuatro meses. Se considera el siguiente salario:

\begin{table}[]
\centering
\caption{Costes de personal}
\label{Salario}
\begin{tabular}{@{}ll@{}}
\toprule
Concepto & Coste \\ \midrule
Salario neto & 1000 \\
Retención IRPF (19 \%) & 360.53 \\
Seguridad social (28,30 \%) & 537.00 \\
Salario bruto & 1897.53 \\ \midrule
4 meses tiempo parcial(3/4) & 5692.59 \\ \bottomrule
\end{tabular}
\end{table}

\subsubsection{Costes de material: hardware y software}

Como material podemos considerar lo mínimo necesario para llevar un proyecto así:

Un único coste puntual (ordenador portátil) que aproximamos en 600 y en la tabla se pondrá su coste amortizado contando con una amortización a 4 años. Se ha comprobado que internet está incluido en el alquiler de la oficina.

\begin{table}[]
\centering
\caption{Costes de material al mes}
\label{Costes mensualmente}
\begin{tabular}{@{}ll@{}}
\toprule
Concepto & Coste \\ \midrule
Ordenador portátil & 25 \\
Alquiler de oficina & 99 \\
1 mes & 124 \\ \midrule
4 meses  & 496 \\ \bottomrule
\end{tabular}
\end{table}


\subsubsection{Costes totales}
El sumatorio de todos los costes es de 6188,59. Podríamos recortar más en ciertos puntos pero debido a que no se va a llevar a cabo como esta planteado aquí, esto solo es una aproximación del coste de oportunidad.




\subsection{Beneficios}
Si nuestro interés fuese vender el proyecto este no sería el proyecto que venderíamos, tendríamos que añadir medidas de tiempo computacional en cada operación.

Una vez consigamos calcular tiempos de computación podemos restringir a cada usuario una cantidad de tiempo. De esta manera podemos crear planes para cada usuario, podemos plantearnos hacer un plan gratuito y varios planes de pago según cantidad de tiempo computacional que se le permita usar al cliente. 


\subsection{Viabilidad legal}

La licencia necesaria para nuestro proyecto debido a las dependencias que tiene tendrá que ser compatible con aquellas de las bibliotecas que hemos usado, la licencia más restrictiva que hemos usado es la de paramiko siendo LGPL (2.1 y 3.0)\cite{LGPL} , esta licencia esta pensada para librerías e incluye el siguiente párrafo:

\begin{quotation}5. A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a "work that uses the Library". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License.
\end{quotation}

Por lo que las restricciones de esa licencia no se nos aplican. Esto quiere decir que podemos publicar nuestro codigo bajo la licencia que mejor nos parezca o incluso podríamos mantenerlo privado como un Secreto de negocio (Trade Secret) ya que proporcionamos SaaS (Software as a Service). Basandome en las licencias más comunes open source, ya que me parece interesante el hecho de que otras personas puedan usar el código, y con ayuda de las recomendaciones de gnu\cite{gnurecs}, se ha decidido usar la GNU GPL 3.0.

Para la documentación se ha decidido que la mejor licencia para las necesidades era la GNU FDL (GNU Free Documentation License). La otra alternativa más interesante era Creative Commons.
